"""
JSON schemas for AI outputs

All AI responses must conform to these strict schemas to ensure
predictable, structured output that can be safely processed.
"""
from typing import TypedDict, Literal, List, Optional


# Task types allowed in the system
TaskType = Literal["concept_review", "practice", "deep_practice", "revision", "mock_test"]

# Difficulty levels
DifficultyLevel = Literal["low", "medium", "high"]

# Cognitive load levels
CognitiveLoad = Literal["low", "medium", "high"]


class LearningTask(TypedDict):
    """
    Schema for a single learning task generated by AI.

    Constraints:
    - suggested_duration_minutes: Must be between 25-60 minutes
    - Tasks must be independent and reorderable
    - No task dependencies allowed
    """
    title: str
    task_type: TaskType
    suggested_duration_minutes: int  # 25-60 only
    difficulty: DifficultyLevel
    cognitive_load: CognitiveLoad
    notes: Optional[str]


class LearningPlan(TypedDict):
    """
    Schema for complete learning plan output from AI.

    This is returned from AI Use Case #1: Event â†’ Learning Plan Generation
    """
    goal_summary: str
    tasks: List[LearningTask]


class TaskSplitSuggestion(TypedDict):
    """
    Suggestion to split a task into smaller units.
    """
    action: Literal["split_task"]
    task_title: str
    new_duration_minutes: int


class ReplanSuggestion(TypedDict):
    """
    Schema for adaptive re-planning suggestions.

    This is returned from AI Use Case #3: Adaptive Re-Planning
    """
    issue_detected: Literal["tasks_overrunning", "tasks_skipped", "event_at_risk"]
    suggestions: List[TaskSplitSuggestion]


def validate_learning_task(task: dict) -> bool:
    """
    Validate a learning task matches the schema.

    Args:
        task: Dictionary containing task data

    Returns:
        True if valid, raises ValueError otherwise
    """
    required_fields = ["title", "task_type", "suggested_duration_minutes",
                      "difficulty", "cognitive_load"]

    # Check required fields
    for field in required_fields:
        if field not in task:
            raise ValueError(f"Missing required field: {field}")

    # Validate task_type
    valid_task_types = ["concept_review", "practice", "deep_practice", "revision", "mock_test"]
    if task["task_type"] not in valid_task_types:
        raise ValueError(f"Invalid task_type: {task['task_type']}")

    # Validate duration (25-60 minutes)
    duration = task["suggested_duration_minutes"]
    if not isinstance(duration, int) or duration < 25 or duration > 60:
        raise ValueError(f"Duration must be 25-60 minutes, got: {duration}")

    # Validate difficulty
    valid_levels = ["low", "medium", "high"]
    if task["difficulty"] not in valid_levels:
        raise ValueError(f"Invalid difficulty: {task['difficulty']}")

    # Validate cognitive_load
    if task["cognitive_load"] not in valid_levels:
        raise ValueError(f"Invalid cognitive_load: {task['cognitive_load']}")

    return True


def validate_learning_plan(plan: dict) -> bool:
    """
    Validate a complete learning plan matches the schema.

    Args:
        plan: Dictionary containing learning plan data

    Returns:
        True if valid, raises ValueError otherwise
    """
    if "goal_summary" not in plan:
        raise ValueError("Missing goal_summary")

    if "tasks" not in plan or not isinstance(plan["tasks"], list):
        raise ValueError("Missing or invalid tasks list")

    if len(plan["tasks"]) == 0:
        raise ValueError("Learning plan must contain at least one task")

    # Validate each task
    for i, task in enumerate(plan["tasks"]):
        try:
            validate_learning_task(task)
        except ValueError as e:
            raise ValueError(f"Task {i} validation failed: {str(e)}")

    return True


# ==================== Phase 3 Schemas ====================

# Emotional state levels
EmotionalLevel = Literal["low", "medium", "high"]

# Error types for diagnostic questions
ErrorType = Literal["conceptual", "application", "reasoning"]

# Adjustment types for plan modifications
AdjustmentType = Literal["shorten", "split", "reorder", "focus_mode_change"]


class DiagnosticErrorGroup(TypedDict):
    """
    Schema for grouped diagnostic errors by topic.
    """
    topic: str
    error_count: int
    question_numbers: List[int]
    error_types: List[ErrorType]
    severity: Literal["low", "medium", "high"]


class DiagnosticAnalysisResult(TypedDict):
    """
    Schema for AI analysis of diagnostic test.

    AI Use Case #4: Diagnostic Test Analysis
    Analyzes error patterns and identifies weak topics.
    """
    total_questions: int
    correct_count: int
    incorrect_count: int
    score_percentage: int
    error_groups: List[DiagnosticErrorGroup]
    dominant_error_topic: Optional[str]
    recommended_review_topics: List[str]
    analysis_summary: str


class EmotionalContext(TypedDict):
    """
    Context about user's emotional state for plan adjustments.
    """
    energy: EmotionalLevel
    stress: EmotionalLevel
    focus: EmotionalLevel
    needs_attention: bool


class PlanAdjustment(TypedDict):
    """
    A single adjustment to be made to the study plan.

    Constraints:
    - type: Must be one of the allowed adjustment types
    - target: Specific session or task to modify
    - new_duration_minutes: Only for shorten/split (25-60 minutes)
    - new_focus_mode: Only for focus_mode_change
    """
    type: AdjustmentType
    target: str  # Which session/task to adjust
    new_duration_minutes: Optional[int]  # For shorten/split
    new_focus_mode: Optional[str]  # For focus_mode_change


class PlanAdjustmentResult(TypedDict):
    """
    Schema for AI-suggested plan adjustments.

    AI Use Case #5: Plan Adjustment Based on Emotional State & Diagnostics
    Suggests modifications to study plan based on user state and test results.

    CRITICAL: Must include detailed rationale explaining why each adjustment
    is suggested and how it addresses the detected issues.
    """
    triggered_by: str  # What triggered this suggestion
    context: dict  # Contains emotional_state, diagnostic_results, etc.
    adjustments: List[PlanAdjustment]
    rationale: str  # MANDATORY: Detailed explanation of why these adjustments are needed


def validate_diagnostic_analysis(analysis: dict) -> bool:
    """
    Validate diagnostic analysis output from AI.

    Args:
        analysis: Dictionary containing diagnostic analysis

    Returns:
        True if valid, raises ValueError otherwise
    """
    required_fields = ["total_questions", "correct_count", "incorrect_count",
                      "score_percentage", "error_groups", "analysis_summary"]

    for field in required_fields:
        if field not in analysis:
            raise ValueError(f"Missing required field: {field}")

    # Validate score_percentage
    if not (0 <= analysis["score_percentage"] <= 100):
        raise ValueError(f"Invalid score_percentage: {analysis['score_percentage']}")

    # Validate error_groups is a list
    if not isinstance(analysis["error_groups"], list):
        raise ValueError("error_groups must be a list")

    # Validate each error group
    for i, group in enumerate(analysis["error_groups"]):
        if "topic" not in group or "error_count" not in group:
            raise ValueError(f"Error group {i} missing required fields")

        if group["error_count"] <= 0:
            raise ValueError(f"Error group {i} has invalid error_count")

    return True


def validate_plan_adjustment(adjustment_result: dict) -> bool:
    """
    Validate plan adjustment suggestion from AI.

    Args:
        adjustment_result: Dictionary containing plan adjustment

    Returns:
        True if valid, raises ValueError otherwise
    """
    required_fields = ["triggered_by", "context", "adjustments", "rationale"]

    for field in required_fields:
        if field not in adjustment_result:
            raise ValueError(f"Missing required field: {field}")

    # CRITICAL: Rationale must not be empty
    if not adjustment_result["rationale"] or len(adjustment_result["rationale"].strip()) < 10:
        raise ValueError("Rationale is required and must be at least 10 characters")

    # Validate adjustments is a list
    if not isinstance(adjustment_result["adjustments"], list):
        raise ValueError("adjustments must be a list")

    if len(adjustment_result["adjustments"]) == 0:
        raise ValueError("At least one adjustment must be specified")

    # Validate each adjustment
    valid_adjustment_types = ["shorten", "split", "reorder", "focus_mode_change"]
    for i, adj in enumerate(adjustment_result["adjustments"]):
        if "type" not in adj or "target" not in adj:
            raise ValueError(f"Adjustment {i} missing required fields")

        if adj["type"] not in valid_adjustment_types:
            raise ValueError(f"Invalid adjustment type: {adj['type']}")

        # Validate duration for shorten/split
        if adj["type"] in ["shorten", "split"]:
            if "new_duration_minutes" not in adj:
                raise ValueError(f"Adjustment {i} of type {adj['type']} requires new_duration_minutes")

            duration = adj["new_duration_minutes"]
            if not isinstance(duration, int) or duration < 25 or duration > 60:
                raise ValueError(f"Invalid duration for adjustment {i}: {duration}")

    return True
